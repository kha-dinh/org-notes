:PROPERTIES:
:ID:       68765dae-6c9b-4a62-bb7f-ab17723a59b9
:END:
#+title: Annotating, Tracking, and Protecting Cryptographic Secrets with CryptoMPK
#+filetags: :paper-notes:

* Summary
This paper use [[id:68bbc446-f046-4df6-b1ed-ba11681a742a][Static Analysis (Source Code Analysis)]] to partition the source
code into crypto and non-crypto domains.

The paper points out that crypto operations have interesting properties.
1. Modern cryptographic operations, on top of the secret keys, use a lot of
   *intermediate values* such as buffers and runtime data. Those data also need to
   be protected, but often overlooked by most mechanisms.
2. Cryptographic operation have data flow that declassify the information. For
   instance, ciphertext have data flow from the key, but is considered
   non-confidential. Traditional [[id:19d7a9ab-1f71-4812-84b9-a9624e6c40e1][Taint Analysis]] ([[id:216535ed-b19c-42d8-af06-119f9c5f421f][DataShield: Configurable Data
   Confidentiality and Integrity]]) would over-taint them (making ciphertext also
   tainted), thus:
   1. Have more performance overhead
   2. Increase the TCB

The paper proposes:
1. From the initial annotations (labels), automatically determine which data to
   protect using *crypto-aware, context-sensitive information flow propagation*
   (a.k.a., [[id:19d7a9ab-1f71-4812-84b9-a9624e6c40e1][Taint Analysis]]), and allows declassification of ciphertext &
   plaintext to avoid over-tainting
2. Using *Context-sensitive Instrumentation* to precisely partition the program.
   This allows the access permission of an instruction can change based on the
   calling context. (Why?)
3. Using [[id:027687ec-a1ba-4d7d-8c56-de4e17cc6e1d][Intel MPK]] to efficiently enforce domain-based isolation.

* Overview
The paper define crypto buffer and crypto operations, then use [[id:68bbc446-f046-4df6-b1ed-ba11681a742a][Static Analysis
(Source Code Analysis)]] to automatically determine crypto buffers and crypto
operations from the initial list of operations. This is somewhat simlilar to
several works that use [[id:19d7a9ab-1f71-4812-84b9-a9624e6c40e1][Taint Analysis]] to propagate secret variables
([[id:5858d065-e920-48c1-9b26-f3fc071a9bf2][PtrSplit]],[[id:216535ed-b19c-42d8-af06-119f9c5f421f][DataShield: Configurable Data Confidentiality and Integrity]] )
** Crypto buffer and crypto operations
+ *Crypto buffer:* memory regions that contains the secret key, or the
  intermediate results of cryptographic computations
+ *Crypto operations:* Operations/instructions that can access the crypto buffers.
  For example, a memory read instruction to the AES key.
** Overview:
1. *Pre-analysis*: Compile the program that contain the annotation into [[id:8c4d5b4c-4f13-48ae-a4af-13c3d5cbc11e][LLVM IR]]
2. *Crypto buffer labeling*: Use [[id:61be9235-539c-4b30-83af-5bc06bbced35][Points-to Analysis]] and [[id:19d7a9ab-1f71-4812-84b9-a9624e6c40e1][Taint Analysis]] to
   label crypto buffers.
3. *Crypto operations identification*: Identify memory accesses and operations
   that access the crypto buffers
4. *Code transformation*:
   1. Move crypto buffers into protected memory regions
   2. Replicate functions to be protected (why?)
   3. Partition program into crypto domain and non-crypto domain
   4. Instrument switches when crossing boundary
   5. Additional binary security checks


* Related works
+ [[id:216535ed-b19c-42d8-af06-119f9c5f421f][DataShield: Configurable Data Confidentiality and Integrity]]
* Notes
+ Weakness: Only target crypto operations
