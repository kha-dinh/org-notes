#+title: Data Flow Analysis

* Overview
+ An analasis in the front end of [[file:20210304170921-compilers.org][Compilers]]
+ Is a process of solving the effect of statements, basic blocks or larger statements.
+ Generate useful information about data at each points
  - To use for optimizations
** Typical informations
+ Available expressions, reaching definitions
+ Alias, live varables, copy propagation
+ Upward exposed uses
** Data flow information (DFI)
+ Abstract property of program data (variable, value, name)
** Data flow equation (DFE)
+ The effect of a statement/block is represented by a *Transfer function* f
* Local DFA
+ Gather the effect of each statements within a basic block
+ Proceeds /statement-by-state/
+ The data flow equation (transfer function): $out[S] = f_{s}(in[S])$
  - (Output DFI after executiing statement S = Input DFI after transfer function)
+ Typical transfer function:
  $f_{s}(in[S]) = gen[S]\cup(in[S] - kill[S])$
  - =gen[S]= : DFI generated by S
  - =kill[S]=: DFI that was  originally in[S], but deleted by S
** Example: Local Reaching Definition
+ The DFI: Which variable definition reach which points of use
+ The *DFE*:
  * =in[S]=: set of definitions thay =may= reach S
  * =out[S]=: set of definitions that are valid right after S
  * =kill[S]=: set of definitions that reach S but are killed (S assigns new values to the definition)
  * =gen[S]= : set of definitions that S asigns values to and _not subsequently killed by itself_
  * The transfer function: $f_{s}(in[S]) = gen[S] \cup (in[S] - kill[S]) = out[S]$
+ /Example/:
  #+begin_src ruby
 # Begin Block
    S10: x := y + 4             # kill[S10] = {x_*}, gen[S10] = {x_S10}

    # Example
    # This statemement kill all previous y, generate a new DFI y_s11
    S11: y := y + v
    # in[S11] = out[S10] = {v_S1, x_S10, y_S9}
    # kill[S11] = {y_*} = {y_S9}, gen[S11] = {y_S11}
    # out[S11] = {y_S11} v ({v_S1, x_S10, y_S9} - {y_S9})
    # in[S12] = out[S11] = {v_S1, x_S10, y_S11}

    S12: z := x * v
    S13: x := x - z
        
    # This statement has no efect on DFI
    S14: goto L on z > 0        # kill[S14] = {}, gen[S14] = {}
# End Block
# out[B] = out[S14] = {v_S1, x_S13, y_S11, z_S12}
  #+end_src
* Global DFA
+ Gather effect of each program segments (basic blocks, loop, intervals)
+ Proceeds along the [[file:20210305151346-control_flow_graph_cfg.org][Control Flow Graph (CFG)]]
+ Transfer function: for a basic block =X=
  $out[X] = f_{x}_{}(in[X])$
  + =in[X]= : DFI given to the block
  + =out[X]=: Output DFI after the block
+ To colect outputs of multiple predecessor blocks:
  $in[X] = \cap_{P \in Pred[X]}out[P]$ (/union of all predecessors/)
** Global Reaching Definition
+ *DFE*
  * =in[B]=: set of definitions thay =may= reach the beginning of B
  * =out[B]=: set of definitions that may reach the end of B
  * =kill[B]=: set of definitions that reach rBbut are killed (B assigns new values to the definition)
  * =gen[B]= : set of definitions that B asigns values to and _not subsequently killed by itself_
  * The transfer function: $f_{B}(in[B]) = gen[B] \cup (in[B] - kill[B]) = out[B]$
  * The process is similar to getting local reaching definition
** /A typical iterative dataflow analysis/
  #+begin_src ruby
for each program segment X do
  intialize out[X];
end
# Loop until there is no more change to the final DFI set
while changes to any out[X] occur do
  for each segment X in DFS order do
    in[X] = ^(all predecessors of X)out[PX]
    out[X] = f(in[X]) # $f_{B}(in[B]) = gen[B] \cup (in[B] - kill[B]) = out[B]
  #+end_src
* A general DFA framework
+ Most data flow problem need
  - DFI
  - tranfer function
  - meet operation (to combine segments)
+ Formalized framework:
  - =V=: Domain of DFI values
  - =F: V \rightarrow V= : Set of f_{B}_{}_{} for each block B
  - =^: V x V \rightarrow V= : A meet operator
